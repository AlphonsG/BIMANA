import os
import re
from collections import defaultdict
from pathlib import Path
from statistics import mean, stdev
from typing import Any

import click
import matplotlib.pyplot as plt
import numpy as np
import numpy.typing as npt
import pandas as pd
from matplotlib.ticker import MultipleLocator

MEAN_COL, STD_COL, SEM_COL = 'Average', 'StDev', 'SEM'
VEHICLE_CONTROL = 'DMSO 0.05%'
POSITIVE_CONTROL = 'Pos 10 µM'
NEGATIVE_CONTROL = 'UT 100%'
PLACEHOLDER_COMPOUNDS = 'CA CB CC CD'
DO_NOT_USE_NOTES_COMPOUNDS = False
DO_NOT_GENERATE_FIGURES = False
FIGURE_TIMEPOINTS = '6 12 24'
FIGURE_METRIC_THRESHOLD = 120


class MetricsTxtFileProcessor:
    """Processes raw .txt files containing live cell imaging metrics.

    The .txt files are those generated by Incuctye Software from a live cell
    imaging experiment, such as airway epithelium wound closure experiments
    utilizing, for example, IncuCyte® ImageLock 96-well plates, IncuCyte®
    ZOOM, etc, and, for example, various drug compounds, such as DMSO for
    control, etc. From these input files, generates data such as image figures
    and excel spreed sheets for analysis.

    Attributes:
        txt_file: The path to the input .txt file.
        metrics_df: A data frame containing the metrics.
        info_df: A data frame containing the experiment information.
        time_df: A data frame containing the time data.
        stats_df: A data frame containing the metrics and computed statistics.
        ctrl_df: A data frame with the metrics for the control compound.
        dfs: A dictionary of the split data frames, with keys of the compounds
            and concentrations per compound.
        fld_chg_df: A data frame containing the metrics in terms of fold
            changes.
        fld_chg_stats_df: A data frame containing the metrics and computed
            statistics in terms of fold changes.
    """

    def __init__(self, txt_file: Path) -> None:
        """Inits MetricsTxtFileProcessor with the .txt file path.

        Args:
            txt_file: The path to the input .txt file.
        """
        self.txt_file = txt_file
        self.stats_df = None

    def _plot_summary(
        self,
        df: pd.DataFrame,
        ax: plt.Axes,
        metric_threshold: int | None = None,
    ) -> None:
        x = [mean(df[c]) for c in df]
        y = [i for i in range(1, len(df.columns) + 1)]
        e = [stdev(df[c]) for c in df]

        ax.errorbar(x, y, xerr=e, linestyle='None', marker='|', color='k',
                    capsize=3.5, markersize=15)
        ax.set_ylim(0, len(df.columns) + 1)
        ax.set(yticks=[i for i in range(1, len(df.columns) + 1)],
               yticklabels=[f'{c}h' for c in df.columns])

        colour = np.random.rand(3,)
        for col in df:
            x = list(df[col])
            y = [list(df.columns).index(col) + 1] * len(x)
            ax.plot(x, y, c=colour, marker='o', linestyle='None',
                    markeredgecolor='k')

        if metric_threshold is not None:
            ax.vlines(metric_threshold, 0, len(df.columns) + 1, linewidth=1,
                      linestyles='dashed')

        ax.xaxis.set_major_locator(MultipleLocator(100))
        ax.xaxis.set_minor_locator(MultipleLocator(50))
        ax.set_xlim(0, 300)

    def _flag(self, x: npt.ArrayLike) -> npt.NDArray[Any]:

        return np.where(x > 25, 'background-color: red;text-align: center',
                        None)

    def _comp_col_wdhs(self, df: pd.DataFrame) -> list[int]:
        col_wdhs = []
        for i in range(0, len(df.columns)):
            for x in df.iloc[:, i]:
                try:
                    val_len = len(str(round(x, 8)))
                except TypeError:
                    val_len = len(str(x))
            col_wdhs.append(max([val_len, len(df.columns[i])]))

        col_wdhs = [x if x != 0 else col_wdhs[i - 1] for i, x in
                    enumerate(col_wdhs)]

        return col_wdhs

    def _get_compounds_and_concentrations(self, df: pd.DataFrame) -> list[str]:
        compds_concs = [well.rsplit(' ', 1)[0] for well in df.columns if
                        well != '']
        compds_concs = list(dict.fromkeys(compds_concs).keys())

        return compds_concs

    def process(
        self,
        use_notes_compounds: bool,
        placeholder_compounds: list[str],
        vehicle_control: str,
        fig_tpts: list[int],
    ) -> None:
        """Processes raw .txt by generating corresponding data frames.

        Args:
            use_notes_compounds: Replace placeholder compound names in the main
                header with compound names listed in the 'Notes' of the input
                text file.
            placeholder_compounds: The placeholder compound names (to be
                replaced with names from the 'Notes' section) in the main
                header of input text files.
            vehicle_control: The vehicle control used in the experiment.
            fig_tpts: The key experiment time points (in hours).
        """
        self.metrics_df, self.info_df, self.time_df = self.create_dataframes()
        if use_notes_compounds:
            self.metrics_df = self.use_notes_compounds(
                self.metrics_df, self.info_df, placeholder_compounds)

        self.stats_df = self.compute_stats(self.metrics_df)
        self.ctrl_df = self.get_compound_dataframe(self.stats_df,
                                                   vehicle_control)
        self.fld_chg_df = self.compute_fold_changes(self.metrics_df,
                                                    self.ctrl_df)
        self.fld_chg_stats_df = self.compute_stats(self.fld_chg_df)
        self.compds_df = self.get_timepoints_dataframe(
            self.fld_chg_df, self.time_df, fig_tpts)
        self.dfs = self.split_dataframe(self.compds_df)

    def create_dataframes(
        self,
    ) -> tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:
        """Creates data frames from the input .txt file.

        Returns:
            A data frame containing the metrics, a data frame containing the
            time data, and a data frame containing the experiment information.
        """
        with open(self.txt_file, encoding='utf-8') as f:
            num_cols = max(len(line.split('\t')) for line in f)
            f.seek(0)
            df = pd.read_csv(f, names=range(num_cols), delimiter='\t',
                             header=None)

        if df.loc[6, 0] is not np.nan:
            df.loc[5.5] = [np.nan] * num_cols
            df = df.sort_index().reset_index(drop=True)

        df.columns = df[7:8].values.tolist()[0]
        info_df, df = df.iloc[0:6, 0].copy(), df[8::]
        info_df = info_df.to_frame()
        info_df.columns = np.arange(1)
        df = df.replace(r'^\s*$', np.nan, regex=True)
        df = pd.concat([df.iloc[:, 0], df.iloc[:, 1::].apply(pd.to_numeric)],
                       axis=1)

        time_df, df = df.iloc[:, 0:2].copy(), df.iloc[:, 2::]
        prev_compd = df.columns[0].rsplit(' ', 1)[0]
        if ' ' not in df.columns[0]:
            prev_compd = re.findall(r'\d+', df.columns[0])[-1]

        df.insert(len(df.columns), '', '', True)
        offset = 0
        for i, well in enumerate(df.iloc[:, 0:-1]):
            if ((' ' in well and (curr_compd := well.rsplit(
                 ' ', 1)[0]) != prev_compd) or (' ' not in well and (
                     curr_compd := re.findall(
                         r'\d+', well)[-1]) != prev_compd)):
                df.insert(i + offset, '', '', True)
                offset += 1
            prev_compd = curr_compd

        return df, info_df, time_df

    def compute_stats(self, metrics_df: pd.DataFrame) -> pd.DataFrame:
        """Computes the statistics of a metrics data frame.

        Statistics consist of the mean, standard deviation and standard error
        of the mean across adjacent rows in the data frame, added as new
        columns.

        Args:
            metrics_df: The metrics data frame.

        Returns:
            The metrics data frame with computed statistics.
        """
        stats_df = metrics_df.copy()
        metrics = defaultdict(list)
        offset = 0
        for i, well in enumerate(metrics_df):
            if well == '':
                means = [mean(ms) for ms in metrics.values()]
                stds = [stdev(ms) for ms in metrics.values()]
                sems = [stds[i] / means[i] * 100 if means[i] != 0 else 0 for i
                        in range(0, len(metrics))]
                stats_df.insert(i + offset, MEAN_COL, means, True)
                stats_df.insert(i + 1 + offset, STD_COL, stds, True)
                stats_df.insert(i + 2 + offset, SEM_COL, sems, True)
                offset += 3
                metrics = defaultdict(list)
            else:
                for i, m in enumerate(metrics_df[well]):
                    if not np.isnan(m):
                        metrics[i].append(m)

        return stats_df

    def get_compound_dataframe(
        self,
        metrics_df: pd.DataFrame,
        compd: str,
    ) -> pd.DataFrame | None:
        """Gets the metrics data frame for the specified compound.

        Args:
            metrics_df: The metrics data frame.
            compd: The specified compound.

        Returns:
            The metrics data frame for the specified compound.
        """
        start_idx = end_idx = None
        for i, well in enumerate(metrics_df):
            if compd in well and start_idx is None:
                start_idx = i
            elif start_idx is not None and well == '':
                end_idx = i
                break

        if start_idx is None or end_idx is None:
            return

        compd_df = metrics_df.iloc[:, start_idx: end_idx + 1]

        return compd_df

    def compute_fold_changes(
        self,
        metrics_df: pd.DataFrame,
        ctrl_df: pd.DataFrame,
    ) -> pd.DataFrame:
        """Computes fold changes for the metrics data frame.

        Fold changes are computed relative to the control control compound.

        Args:
            metrics_df: The metrics data frame.
            ctrl_df: A data frame with the metrics for the control compound.

        Returns:
            A metrics data frame with fold changes.
        """
        fld_chg_df = metrics_df.copy()
        ctrl_idx = 0
        for well in metrics_df:
            if well != '':
                fld_chg_df[well] /= ctrl_df[MEAN_COL]
                fld_chg_df[well] *= 100
                ctrl_idx += 1
            else:
                ctrl_idx = 0

        fld_chg_df.fillna(0, inplace=True)

        return fld_chg_df

    def get_timepoints_dataframe(
        self,
        metrics_df: pd.DataFrame,
        time_df: pd.DataFrame,
        timepoints: list[int],
    ) -> pd.DataFrame:
        """Gets the metrics data frame for the specified time points only.

        Args:
            metrics_df: The metrics data frame.
            time_df: The time data frame.
            timepoints: A sequence of time points to select.

        Returns:
            The metrics data frame for the specified time points.
        """
        df = pd.concat([time_df, metrics_df], axis=1)
        compds_df = df[time_df['Elapsed'].isin(timepoints)]

        return compds_df

    def split_dataframe(
        self,
        metrics_df: pd.DataFrame,
    ) -> dict[str, dict[str, pd.DataFrame]] | None:
        """Splits a data frame by empty columns into multiple data frames.

        Args:
            metrics_df: The metrics data frame.

        Returns:
            A dictionary of the split data frames, with keys of the compounds
            and concentrations per compound.
        """
        compds_concs = self._get_compounds_and_concentrations(
            metrics_df.iloc[:, 2::])
        dfs = {}
        i = 0
        for j in range(0, len(metrics_df.columns)):
            if metrics_df.columns[j] == '':
                compd, conc = compds_concs[i].split(' ', 1)
                compd_df = self.get_compound_dataframe(metrics_df,
                                                       compds_concs[i])
                dfs.setdefault(compd, {})
                compd_df = pd.concat([metrics_df['Elapsed'], compd_df], axis=1)
                columns = compd_df['Elapsed']
                compd_df = compd_df.iloc[:, 1:-1].transpose()
                compd_df.columns = list(columns)
                dfs[compd][conc] = compd_df
                i += 1

        return dfs

    def generate_compound_summary_figs(
        self,
        veh_ctrl: str,
        pos_ctrl: str,
        neg_ctrl: str,
        metric_threshold: int,
        output_dir: Path,
        dpi: int = 600,
    ) -> None:
        """Generates and saves figures visualizing experiment data.

        Args:
            veh_ctrl: The name of the vehicle control.
            pos_ctrl: The name of the positive control.
            neg_ctrl: The name of the negative control.
            metric_threshold: The metric threshold to show in the generated
                figures.
            output_dir: The output directory to save figures in.
            dpi: The dpi of the figures.
        """
        dfs = self.dfs
        compds = list(dfs.keys())
        num_ctrls = 0
        for ctrl in [pos_ctrl, neg_ctrl]:
            if ctrl in compds:
                num_ctrls += 1
                compds.remove(ctrl)

        num_axes = len(compds) + num_ctrls
        if veh_ctrl in compds:
            num_axes -= 1
        np.random.seed(0)
        figs = {}
        for compd in compds:
            if compd == veh_ctrl:
                continue
            fig, axes = plt.subplots(num_axes, figsize=(6, 10), sharex=True)
            if not isinstance(axes, list) and not isinstance(axes, np.ndarray):
                axes = [axes]
            i = 0
            last_ctrl_idx = None
            for ctrl, label in zip([neg_ctrl, pos_ctrl],
                                ['-ve\nControl', '+ve\nControl']):
                try:
                    df = list(dfs[ctrl].values())[0]
                except KeyError:
                    continue

                self._plot_summary(df, axes[i], metric_threshold)
                axes[i].set_ylabel(label)
                last_ctrl_idx = i
                i += 1

            for conc, df in dfs[compd].items():
                self._plot_summary(df, axes[i], metric_threshold)
                axes[i].set_ylabel(conc)
                i += 1
            if last_ctrl_idx is not None:
                axes[last_ctrl_idx].tick_params(axis='x', which='both',
                                                bottom=False)
                axes[last_ctrl_idx].spines['bottom'].set_linestyle((0, (8, 5)))
                axes[last_ctrl_idx].spines['bottom'].set_color('red')

            for x in range(0, i):
                axes[x].spines['top'].set_visible(False)
                axes[x].spines['right'].set_visible(False)
                if x == len(axes) - 1 or last_ctrl_idx == x:
                    continue
                axes[x].spines['bottom'].set_visible(False)
                axes[x].axes.get_xaxis().set_visible(False)

            plt.suptitle(compd, fontweight='bold', y=1)
            plt.xlabel('Wound Closure Relative to VEH (%)')
            fig.subplots_adjust(hspace=0)
            plt.setp([a.get_xticklabels() for a in fig.axes[:-1]],
                     visible=False)
            fig.tight_layout()
            figs[compd] = plt.gcf()

        for compd, fig in figs.items():
            fig.savefig(os.path.join(output_dir, f'{compd}_wound_closure.png'),
                        dpi=dpi)
            plt.close(fig)

    def use_notes_compounds(
        self,
        metrics_df: pd.DataFrame,
        info_df: pd.DataFrame,
        ph_compds: list[str],
    ) -> pd.DataFrame:
        """Uses compounds from the experiment notes in the metrics data frame.

        Hence replaces the existing (placeholder) compounds in the metrics data
        frame header. The compounds in the notes must be separated by an
        underscore e.g. "Notes: C55_C56_C57_C58".

        Args:
            metrics_df: The metrics data frame.
            info_df: The experiment information data frame containing the
                notes.
            ph_compds: A sequence of names for the placeholder compounds to
                replace in the metrics data frame header. Each compound in the
                experiment notes will be mapped to each placeholder in this
                sequence in order.
        """
        notes_compds = info_df.iloc[4][0].split('Notes: ')[1]
        notes_compds = notes_compds.split('_')
        compd_map = {ph_compd: notes_compd for ph_compd, notes_compd in zip(
                    ph_compds, notes_compds)}
        columns = list(metrics_df.columns)

        for i, df_compd in enumerate(columns):
            df_compd = df_compd.split(' ')[0]
            if df_compd in compd_map:
                columns[i] = columns[i].replace(df_compd, compd_map[df_compd])
        metrics_df.columns = columns

        return metrics_df

    def gen_analysed_excel(
        self,
        output_path: Path,
    ) -> None:
        """Generates an excel spreadsheet from data frames and saves as a file.

        Args:
            output_path: The path of the output excel file to create.
        """
        df = self.stats_df
        fld_chg_df = self.fld_chg_stats_df
        time_df = self.time_df
        info_df = self.info_df
        with pd.ExcelWriter(output_path) as writer:
            workbook = writer.book
            info_df.to_excel(writer, startrow=0, index=False, header=False)
            ws = writer.sheets['Sheet1']
            header_format = workbook.add_format({'bold': True,
                                                 'valign': 'centre'})
            old_headers = list(df.columns)
            header_mapping2 = [x for x in old_headers]
            header_mapping = [i for i, _ in enumerate(old_headers)]

            old_headers = list(df.columns)
            header_mapping2 = list(time_df.columns) + [x for x in old_headers]
            header_mapping = [i for i, _ in enumerate(old_headers)]
            df.columns = header_mapping
            fld_chg_df.columns = header_mapping
            df = pd.concat([time_df, df], axis=1)
            fld_chg_df = pd.concat([time_df, fld_chg_df], axis=1)
            df.columns = header_mapping2
            fld_chg_df.columns = header_mapping2
            old_headers = list(df.columns)
            header_mapping = [i for i, _ in enumerate(old_headers)]

            df.to_excel(writer, startrow=8, index=False, header=False)

            mean_cols = [i for i, x in enumerate(old_headers) if x == STD_COL]
            fld_chg_df.columns = pd.Index(header_mapping)
            fld_chg_df_style = fld_chg_df.style.apply(self._flag, axis=0,
                                                      subset=mean_cols)
            mean_cols = [i for i, x in enumerate(old_headers) if x == SEM_COL]
            fld_chg_df_style.columns = pd.Index(header_mapping)
            fld_chg_df_style = fld_chg_df_style.apply(self._flag, axis=0,
                                                      subset=mean_cols)

            fld_chg_df_style.to_excel(writer, startrow=len(df) + 10,
                                      index=False, header=False)
            fld_chg_df.columns = header_mapping2
            for col_num, value in enumerate(df.columns.values):
                ws.write(7, col_num, value, header_format)

            for col_num, value in enumerate(fld_chg_df.columns.values):
                ws.write(len(df) + 9, col_num, value, header_format)

            for i, wdh in enumerate(self._comp_col_wdhs(df)):
                ws.set_column(i, i, wdh)

            for i in range(7, len(df) + 10 + len(df)):
                cell_format = workbook.add_format({'valign': 'centre'})
                ws.set_row(i, cell_format=cell_format)


@click.command()
@click.argument('root_directory', type=click.Path(
                exists=True, file_okay=False))
@click.option('--vehicle-control', default=VEHICLE_CONTROL, show_default=True,
              help='Vehicle control used in the experiment.')
@click.option('--positive-control', default=POSITIVE_CONTROL,
              show_default=True,
              help='Positive control used in the experiment.')
@click.option('--negative-control', default=NEGATIVE_CONTROL,
              show_default=True,
              help='Negative control used in the experiment')
@click.option('--placeholder-compounds', required=True, show_default=True,
              default=PLACEHOLDER_COMPOUNDS, help='The placeholder '
              'compound names (to be replaced with names from the \'Notes:\' '
              'section) in the main header of input text files.')
@click.option('--do-not-use-notes-compounds', is_flag=True,
              help='Do not use compound names listed in the \'Notes\' section '
              'of input text files (by mapping compounds names in notes to '
              'compound name placeholders in the main header columns), '
              'instead use compound names in the main header.')
@click.option('--do-not-generate-figures', is_flag=True,
              help='Do not generate box plot figures for the wound closure '
              'over vehicle control (%) at various time points and '
              'concentrations to summarize compound performance.')
@click.option('--figure-timepoints', required=True, show_default=True,
              default=FIGURE_TIMEPOINTS, help='The time points to show (in '
              'hours) in the generated figures.')
@click.option('--figure-metric-threshold', default=FIGURE_METRIC_THRESHOLD,
              show_default=True,
              help='The metric threshold to show in the generated figure.')
def metrics_file_processing(
    root_directory: str,
    vehicle_control: str = VEHICLE_CONTROL,
    positive_control: str = POSITIVE_CONTROL,
    negative_control: str = NEGATIVE_CONTROL,
    placeholder_compounds: str = PLACEHOLDER_COMPOUNDS,
    do_not_use_notes_compounds: bool = DO_NOT_USE_NOTES_COMPOUNDS,
    do_not_generate_figures: bool = DO_NOT_GENERATE_FIGURES,
    figure_timepoints: str = FIGURE_TIMEPOINTS,
    figure_metric_threshold: int = FIGURE_METRIC_THRESHOLD,
) -> None:
    """Processes raw .txt files containing live cell imaging metrics.

    The .txt files are those generated by Incuctye Software from a live cell
    imaging experiment, such as airway epithelium wound closure experiments
    utilizing, for example, IncuCyte® ImageLock 96-well plates, IncuCyte®
    ZOOM, etc, and, for example, various drug compounds, such as DMSO for
    control, etc. From these input files, generates data such as image figures
    and excel spreed sheets for analysis.

    ROOT_DIRECTORY:

    The directory to search for .txt files to process in. When using the web
    interface, directory must be zipped.
    """
    try:
        fig_tpts = [int(t) for t in figure_timepoints.split()]
    except ValueError:
        click.echo('Invalid value provided for \'...--figure-timepoints\' '
                   'option.')
        return

    for f in [f for f in Path(root_directory).iterdir() if f.is_file() and
              f.suffix == '.txt']:
        processor = MetricsTxtFileProcessor(f)
        processor.process(not do_not_use_notes_compounds,
                          placeholder_compounds.split(), vehicle_control,
                          fig_tpts)
        output_dir = f.parent / f.name.replace('.txt', '_txt')
        output_dir.mkdir(exist_ok=True)

        output_excel_file = output_dir / (f.stem + '_analysed.xlsx')
        processor.gen_analysed_excel(output_excel_file)

        if not do_not_generate_figures:
            processor.generate_compound_summary_figs(
                vehicle_control.split(' ')[0],
                positive_control.split(' ')[0],
                negative_control.split(' ')[0], figure_metric_threshold,
                output_dir)
